name: Provisioning On-Demand-Services

on:
  repository_dispatch:
    types: [event-on-demand-services]

permissions:
  id-token: write
  contents: read

env:
  OWNER: "ashish-soni-org"
  ACTION_TYPE: "ADD_SERVICES"

jobs:

  # ----------------------------------------------------
  #             SERVICE PROVISION
  # ----------------------------------------------------

  service_provision:
    name: Provisioning required services
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform

    steps:
      - name: Setup AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION_NAME }}

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.14.2

      - name: Load and Merge Provisioning Manifest
        run: |
          set -e

          # 1. Fetch existing manifest from S3 or initialize a valid Schema Object
          # NOTE: The schema MUST be an Object { "vpcs": [], "standalone": [] } 
          # to match the Terraform variables.
          if aws s3 ls "s3://${{ secrets.AWS_TF_STATE_FILE_BUCKET }}/${{ secrets.AWS_TF_STATE_MANIFEST_FILE_PATH }}" > /dev/null 2>&1; then
            aws s3 cp "s3://${{ secrets.AWS_TF_STATE_FILE_BUCKET }}/${{ secrets.AWS_TF_STATE_MANIFEST_FILE_PATH }}" old.json
          else
            echo '{"vpcs": [], "standalone": []}' > old.json
          fi

          # 2. Process the incoming JSON payload (The array of new services)
          echo '${{ toJSON(github.event.client_payload.services) }}' > new_services.json

          # 3. Validate Inputs
          # Ensure old.json is an Object and new_services.json is an Array
          if ! jq -e 'type == "object"' old.json > /dev/null; then
             echo "::error::Existing state is corrupt (not an object). Resetting."
             echo '{"vpcs": [], "standalone": []}' > old.json
          fi
          if ! jq -e 'type == "array"' new_services.json > /dev/null; then
             echo "::error::Input services payload must be an Array. Received: $(cat new_services.json)"
             exit 1
          fi

          # 4. Merge Logic
          # We append the new services array to the existing .standalone array
          # and ensure uniqueness to avoid duplicates.
          jq --slurpfile new new_services.json \
             '.standalone = (.standalone + $new[0]) | .standalone |= unique' \
             old.json > merged.json

          # 5. Persist updated manifest back to S3
          aws s3 cp merged.json "s3://${{ secrets.AWS_TF_STATE_FILE_BUCKET }}/${{ secrets.AWS_TF_STATE_MANIFEST_FILE_PATH }}"

          # 6. Generate Terraform variables
          # Wraps the merged object into the "ui_manifest" variable
          echo "{\"ui_manifest\": $(cat merged.json)}" > terraform.tfvars.json

      - name: Initialize Terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_FILE_BUCKET }}" \
            -backend-config="key=${{ secrets.AWS_TF_STATE_FILE_PATH }}" \
            -backend-config="region=${{ secrets.AWS_REGION_NAME }}" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        run: terraform apply -auto-approve

      - name: Capture Terraform Outputs
        id: tf_outputs
        run: |
          # Extract the map and convert to a single-line JSON string
          PROVISIONED_JSON=$(terraform output -json provisioned_resources | jq -c '.')
          echo "TF_PROVISIONED_MAP=$PROVISIONED_JSON" >> $GITHUB_ENV

      - name: Update Provisioned Services (Secrets Manager)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      
      - name: Run Secrets Manager Script
        run: |
          pip install boto3 botocore
          python ../.github/workflows/secretsManager.py
        env:
          AWS_REGION: ${{ secrets.AWS_REGION_NAME }}
          SECRET_FILE_NAME: ${{ secrets.SECRETS_FILE_NAME }}
          ACTION_TYPE: ${{ env.ACTION_TYPE }}
          REPO_NAME: ${{ github.event.client_payload.repo }}
          PROVISIONED_MAP: ${{ env.TF_PROVISIONED_MAP }}
            
  deploy_website_and_projects:
    name: Trigger Source Repository Build
    needs: [service_provision]
    if: success()
    runs-on: ubuntu-latest

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ env.OWNER }}
          repositories: ${{ github.event.client_payload.repo }}

      - name: Trigger Other Repositories
        run: |
          curl -X POST \
            -H "Authorization: Bearer ${{ steps.app-token.outputs.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ env.OWNER }}/${{ github.event.client_payload.repo }}/dispatches \
            -d '{"event_type":"event-on-demand-build","client_payload":{}}'